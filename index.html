<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Practical Network Mindmap — Components and Links</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Layout and theme */
    :root{
      --bg:#0f1221;
      --panel:#0c1230;
      --card:#151c45;
      --ink:#eef1ff;
      --muted:#b8c0e6;
      --edge:#89bdff;
      --edge-soft:#405089;
      --center:#ffc86e;
      --hub:#20e6b2;
      --radius:18px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;overflow:hidden}
    .bar{
      position:fixed; inset:0 0 auto 0; z-index:5;
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 14px; background:var(--panel); border-bottom:1px solid #223063;
    }
    .title{font-weight:800}
    .hint{color:var(--muted);font-size:12px}
    .btn{
      appearance:none; border:2px solid #4e63d9; background:#12173a; color:#dfe6ff;
      padding:6px 10px; border-radius:10px; cursor:pointer; font-weight:600
    }
    .btn:active{transform:translateY(1px)}
    .zoomval{color:#cfe2ff;font-weight:700;margin-left:6px}

    /* Stage with true pan and zoom */
    #stage{position:fixed; inset:48px 0 0 0; background:#0f1221; cursor:grab; user-select:none}
    #stage.dragging{cursor:grabbing}
    #viewport{
      position:absolute; left:0; top:0; transform-origin:0 0;
      /* Big content area so everything fits without browser zoom */
      width:1px; height:1px; /* size is irrelevant, transform moves content */
    }

    /* Background grid in content space */
    #grid{position:absolute; left:0; top:0; width:1px; height:1px; overflow:visible; pointer-events:none}
    #grid line{stroke:#16204e;stroke-width:1}

    /* Edges as SVG, overflow visible so paths can extend anywhere */
    #edges{position:absolute; left:0; top:0; width:1px; height:1px; overflow:visible; pointer-events:none}
    .edge{fill:none;stroke:var(--edge-soft);stroke-width:3;stroke-linecap:round;opacity:.95}
    .edge.center{stroke:var(--edge);stroke-width:4;opacity:1}

    /* Cards as simple HTML for reliable events and performance */
    .card{
      position:absolute;
      width:460px;
      background:linear-gradient(180deg,#1b2354 0%, var(--card) 100%);
      border:3px solid #3b58d1;
      border-radius:var(--radius);
      color:var(--ink);
      box-shadow:0 18px 36px rgba(0,0,0,.42);
      padding:12px 14px;
      outline:2px solid rgba(255,255,255,.10);
    }
    .card.center{ border-color:#f3a84a }
    .card.hub{ border-color:#20e6b2 }
    .card:hover{ outline-color:rgba(255,255,255,.28) }

    .chips{display:flex;flex-wrap:wrap;margin:6px 0}
    .tag{
      display:inline-block;font-size:11px;
      color:#0f142d;background:#cfe2ff;border:1px solid #6ea3ff;border-radius:999px;
      padding:2px 8px;margin:0 6px 6px 0
    }
    .name{font-weight:800;margin:2px 0 6px;letter-spacing:.2px}
    .what,.link{font-size:12.5px;color:var(--muted);margin:6px 0}

    /* Fixed tooltip bottom-right, never moves with zoom */
    .tip{
      position:fixed; right:18px; bottom:18px; z-index:6;
      width:520px; max-height:50vh; overflow:auto;
      background:rgba(13,18,48,.95);
      border:2px solid #4e63d9; border-radius:14px;
      box-shadow:0 14px 28px rgba(0,0,0,.45);
      padding:12px 14px; backdrop-filter: blur(6px)
    }
    .tip h3{margin:0 0 6px;font-size:14px}
    .tip .mini{color:var(--muted);font-size:12px;margin:0 0 8px}
    .tip .def{font-size:12.5px;margin:6px 0}
    .tip code{background:#0d1438;border:1px solid #2c3a86;border-radius:6px;padding:0 6px;margin-right:6px;color:#bcd0ff}
  </style>
</head>
<body>
  <div class="bar">
    <div class="title">Practical Network Mindmap</div>
    <button class="btn" id="btnZoomOut">Zoom −</button>
    <button class="btn" id="btnZoomIn">Zoom +</button>
    <button class="btn" id="btnFit">Fit</button>
    <button class="btn" id="btnReset">Reset</button>
    <span class="zoomval" id="zoomVal">100%</span>
    <span class="hint">Drag to pan. Wheel to zoom at cursor. Header and tooltip do not move.</span>
  </div>

  <div id="stage" aria-label="Mindmap canvas">
    <div id="viewport">
      <svg id="grid"></svg>
      <svg id="edges"></svg>
      <div id="nodes"></div>
    </div>
  </div>

  <div id="tip" class="tip" aria-live="polite">
    <h3>Hover a component</h3>
    <p class="mini">You will see short, plain definitions here. Always meaning first, acronym in parentheses.</p>
    <div class="def"><code>VLAN</code> Virtual local area network, separate broadcast domains on one switch (VLAN).</div>
    <div class="def"><code>SVI</code> Layer 3 interface on a switch that acts as the default gateway for a VLAN (SVI).</div>
  </div>

  <script>
    /* ---------------------------------------------------------
       Lightweight pan and zoom
       - HTML cards positioned absolutely in a virtual space
       - One SVG for edges and one SVG for the grid
       - A single CSS transform on #viewport does the zoom
       --------------------------------------------------------- */

    // Simple glossary with meaning first, acronym in parentheses
    const GLOSSARY = {
      "VLAN":"Virtual local area network, separate broadcast domains on one switch (VLAN).",
      "802.1Q":"VLAN tagging method that inserts a small identifier in the frame (802.1Q).",
      "TRUNK":"Link that carries multiple VLANs between switches or to routers (TRUNK).",
      "STP":"Loop prevention that blocks redundant paths and reconverges on failure (STP).",
      "MSTP":"Spanning tree that groups VLANs into a few instances for scale (MSTP).",
      "LACP":"Link bundling so multiple cables act as one logical port-channel (LACP).",
      "SVI":"Layer 3 interface on a switch that serves as the VLAN gateway (SVI).",
      "RoaS":"Single router interface split into subinterfaces for many VLANs (RoaS).",
      "OSPF":"Interior routing that builds a map of links and picks shortest paths (OSPF).",
      "EIGRP":"Cisco interior routing with fast convergence using a loop-free algorithm (EIGRP).",
      "BGP":"Policy driven routing used between networks and for large fabrics (BGP).",
      "NAT":"Address translation that maps private addresses to public space (NAT).",
      "VRF":"Separate routing tables on one device for clean tenant separation (VRF).",
      "VXLAN":"Encapsulation that carries layer 2 across layer 3 networks (VXLAN).",
      "EVPN":"Control plane that advertises hosts and networks for VXLAN overlays (EVPN).",
      "PVLAN":"Layer 2 isolation inside one subnet to stop lateral traffic (PVLAN).",
      "HSRP":"Virtual gateway with active and standby devices for failover (HSRP).",
      "VRRP":"Open version of a virtual gateway with active and backup roles (VRRP).",
      "ECMP":"Routing that splits flows across several equal paths (ECMP).",
      "ACL":"Traffic filter that permits or denies by address and port (ACL).",
      "NGFW":"Stateful firewall that can identify applications and users (NGFW).",
      "IDS":"Inspection that detects attacks, IPS can block them inline (IDS).",
      "802.1X":"Port authentication that checks identity before giving access (802.1X).",
      "VPN":"Encrypted tunnel for remote users or sites (VPN).",
      "MFA":"Extra identity factor beyond password to reduce account takeover (MFA).",
      "SNMP":"Device counters and health exposed for monitoring (SNMP).",
      "NetFlow":"Summary of who talks to whom and how much (NetFlow).",
      "Syslog":"Device event messages collected centrally for audits and incidents (Syslog).",
      "SPAN":"Copy of packets sent to a port for analysis, RSPAN can extend it (SPAN).",
      "PCAP":"Packet capture used to inspect real traffic in detail (PCAP).",
      "DHCP":"Automatic address and option assignment to clients (DHCP).",
      "DNS":"Name to address lookup for apps and services (DNS).",
      "NTP":"Clock sync so logs and security checks line up in time (NTP).",
      "AAA":"Central login, permission, and accounting for admins and users (AAA).",
      "BACKUP":"Saved copies of configuration used for rollback and audits (BACKUP).",
      "TEMPLATE":"Reusable configuration blocks that keep devices consistent (TEMPLATE).",
      "TEST":"Planned failover or link pulls to prove resilience under load (TEST).",
      "L2":"Layer 2 switching domain with frames and MAC addresses (L2).",
      "L3":"Layer 3 routing domain with IP and next hops (L3).",
      "Mgmt":"Out of band or in band management and telemetry plane (Mgmt).",
      "App":"Application level services that users and systems call (App).",
      "Infra":"Core time and identity helpers that everything depends on (Infra).",
      "Ops":"Operational practices such as backups and drills (Ops)."
    };

    // Data: categories and concrete components
    const model = {
      center: {
        name:"Network components and how they connect",
        what:"Tangible pieces you configure in production.",
        link:"Use this map to plan changes and spot dependencies fast.",
        tags:["L2","L3","Mgmt","Ops"]
      },
      categories: [
        { id:"L2",   name:"Layer 2 switching and loops" },
        { id:"L3",   name:"Layer 3 routing and gateways" },
        { id:"SEG",  name:"Segmentation and overlays" },
        { id:"HA",   name:"High availability" },
        { id:"SEC",  name:"Security controls and boundaries" },
        { id:"TEL",  name:"Telemetry and visibility" },
        { id:"SERV", name:"Core services and identity" },
        { id:"OPS",  name:"Operations and testing" }
      ],
      items: {
        L2: [
          node("VLAN","VLAN (802.1Q)",["L2","VLAN","802.1Q"],"Separate broadcast domains on one switch.","Feeds inter-VLAN routing. Uses trunks. Protected by spanning tree."),
          node("TRUNK","Trunks",["L2","TRUNK","802.1Q"],"Carry multiple VLANs over one link.","Connects switches and router-on-a-stick. Needed so SVIs see traffic."),
          node("STP","STP RSTP MSTP",["L2","STP","MSTP"],"Prevents loops and converges on failure.","Works under VLANs and trunks. Cooperates with link aggregation."),
          node("LACP","EtherChannel",["L2","LACP"],"Bonds links into one logical pipe.","Used for resilient trunks and server uplinks.")
        ],
        L3: [
          node("SVI","SVI gateways",["L3","SVI"],"Default gateway per VLAN on the switch.","Depends on VLAN presence. Often paired with a virtual gateway."),
          node("RoaS","Router on a stick",["L3","RoaS","802.1Q"],"Router subinterfaces per VLAN on one port.","Good in labs and small sites. Replaced by SVIs when scale grows."),
          node("OSPF","OSPF",["L3","OSPF"],"Interior routing that finds shortest paths.","Advertises VLAN gateways and transit links. Enables equal paths."),
          node("EIGRP","EIGRP",["L3","EIGRP"],"Cisco interior routing with fast convergence.","Alternative to OSPF in single-vendor networks."),
          node("BGP","BGP",["L3","BGP","EVPN"],"Policy driven routing between networks.","Used at internet edges and for overlays. Needs a stable underlay."),
          node("NAT","NAT PAT",["L3","NAT"],"Maps private space to public addresses.","Lives at borders next to the firewall. Needs correct return paths.")
        ],
        SEG: [
          node("VRF","VRF",["L3","VRF"],"Separate routing tables on one device.","Pairs with VLANs and filters. Each VRF runs its own routing."),
          node("VXLAN","VXLAN overlays",["L2","VXLAN","EVPN"],"Carries layer 2 across layer 3 fabric.","Rides the underlay routing. Requires higher MTU."),
          node("PVLAN","Private VLAN",["L2","PVLAN"],"Isolates hosts inside a subnet.","Useful in DMZ or multi-tenant racks with a shared gateway.")
        ],
        HA: [
          node("HSRP","HSRP VRRP",["L3","HSRP","VRRP"],"Virtual gateway with active and standby.","Fronts SVIs or routed links. Keep peer configs aligned."),
          node("ECMP","ECMP",["L3","ECMP"],"Splits flows across equal routes.","Comes from the interior routing or policies. Works best on similar links."),
          node("DUAL","Dual power and paths",["Ops","L2","L3"],"Two power feeds and independent uplinks.","Supports every other control. Combine with aggregation and virtual gateways.")
        ],
        SEC: [
          node("ACL","ACLs",["L3","ACL"],"Permit or deny by address and port.","Applied on SVIs, routed links, and device lines. Mirror for IPv6."),
          node("NGFW","Next gen firewall",["L3","NGFW"],"Stateful filtering with app awareness.","Place at boundaries. Uses routes and identity to decide."),
          node("IDS","IDS IPS",["L3","IDS"],"Detects attacks, can block inline.","Inline or via mirrored traffic. Send findings to security logs."),
          node("8021X","802.1X and NAC",["L2","802.1X","AAA"],"Port access by identity before network use.","Assigns VLAN or VRF dynamically. Can add per user filters."),
          node("VPN","VPN and MFA",["L3","VPN","MFA"],"Encrypted access for users or sites.","Integrates with routing. Use strong identity.")
        ],
        TEL: [
          node("SNMP","SNMP",["Mgmt","SNMP"],"Device counters and health.","Feeds dashboards and alerts. Useful for capacity plans."),
          node("NetFlow","NetFlow IPFIX",["Mgmt","NetFlow"],"Who talks to whom and how much.","Explains spikes and helps security checks."),
          node("Syslog","Syslog",["Mgmt","Syslog"],"Device event messages with reasons.","Central store for audits and incident timelines."),
          node("SPAN","SPAN RSPAN",["L2","SPAN"],"Copy packets to an analysis port.","Use with packet capture for truth on the wire."),
          node("PCAP","Wireshark",["Mgmt","PCAP"],"Deep packet inspection of real traffic.","Confirms or disproves what counters suggest.")
        ],
        SERV: [
          node("DHCP","DHCP",["L3","DHCP"],"Hands out addresses and options to clients.","Needs helper on VLAN interfaces. Scopes per segment."),
          node("DNS","DNS",["App","DNS"],"Name to address lookup.","Create records for both address families. Slow name service feels like an outage."),
          node("NTP","NTP",["Infra","NTP"],"Clock sync for devices and servers.","Logs and security checks rely on correct time."),
          node("AAA","RADIUS TACACS+",["Mgmt","AAA"],"Central login and permissions for admins and users.","Backs port authentication and device access.")
        ],
        OPS: [
          node("BACKUP","Config backups",["Ops","BACKUP"],"Versioned configs stored off device.","Used for rollback and audits."),
          node("TEMPLATE","Templates and automation",["Ops","TEMPLATE"],"Reusable config blocks that cut typos.","Apply standards across VLANs, gateways, routing, and filters."),
          node("TEST","Failover tests",["Ops","TEST"],"Planned link pulls and switchovers.","Proves virtual gateways, equal paths, and spanning tree under load.")
        ]
      }
    };

    // Helpers to create nodes
    function node(tag,name,tags,what,link){ return { tag,name,tags,what,link }; }

    /* -----------------------------
       Build layout coordinates
       ----------------------------- */
    const hubs = [];
    const leaves = [];
    const hubRadius = 3200;                 // very big spacing from center
    const hubAngles = [-90,-35,20,80,135,-155,180,0];

    // Center at (0,0)
    const centerNode = {
      x:-230, y:-120, w:460, h:240,
      name:model.center.name, tags:model.center.tags,
      what:model.center.what, link:model.center.link, cls:"center"
    };

    // Hub positions around a circle
    model.categories.forEach((c,i)=>{
      const p = polar(0,0,hubRadius,hubAngles[i]);
      const hub = {
        id:c.id, name:c.name, tags:["Mgmt","Ops","L2","L3"], // generic tags
        what:"Family of components you use in production.",
        link:"Connects to the core map and the parts below.",
        x: p.x - 230, y: p.y - 100, w:460, h:200, cls:"hub"
      };
      hubs.push(hub);

      // Leaves spread away from hub with strong lateral offset
      const group = model.items[c.id] || [];
      const dir = norm({x:p.x, y:p.y});
      const perp = {x:-dir.y, y:dir.x};
      group.forEach((leaf,i2)=>{
        const base = 1100 + i2*760;                   // distance out from hub
        const spread = (i2 - (group.length-1)/2) * 520;
        const cx = p.x + dir.x*base + perp.x*spread;
        const cy = p.y + dir.y*base + perp.y*spread;
        leaves.push({
          parent:c.id,
          name:leaf.name, tags:[...leaf.tags], what:leaf.what, link:leaf.link,
          x: cx - 230, y: cy - 120, w:460, h:240, cls:""
        });
      });
    });

    /* -----------------------------
       Render grid, edges, nodes
       ----------------------------- */
    const stage = document.getElementById('stage');
    const viewport = document.getElementById('viewport');
    const grid = document.getElementById('grid');
    const edges = document.getElementById('edges');
    const nodes = document.getElementById('nodes');
    const zoomVal = document.getElementById('zoomVal');
    const tip = document.getElementById('tip');

    // Huge grid
    drawGrid(-14000, -10000, 28000, 20000, 400);

    // Edges: center to hubs
    hubs.forEach(h=>{
      drawEdge(240,100, h.x, h.y+100, true); // from center card corner
    });
    // Edges: hubs to leaves
    leaves.forEach(l=>{
      const hub = hubs.find(x=>x.id===l.parent);
      drawEdge(hub.x+hub.w, hub.y+hub.h/2, l.x, l.y+l.h/2, false);
    });

    // Nodes
    addCard(centerNode);
    hubs.forEach(addCard);
    leaves.forEach(addCard);

    /* -----------------------------
       Pan and zoom controls
       ----------------------------- */
    let scale = 1, minScale = 0.25, maxScale = 4;
    let tx = stage.clientWidth/2, ty = stage.clientHeight/2;
    applyTransform();

    // Wheel zoom at cursor
    stage.addEventListener('wheel', e=>{
      e.preventDefault();
      const rect = stage.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const prev = scale;
      const factor = Math.exp((-e.deltaY) * 0.0016);
      scale = clamp(prev*factor, minScale, maxScale);

      const cx = (sx - tx) / prev;
      const cy = (sy - ty) / prev;
      tx = sx - cx * scale;
      ty = sy - cy * scale;

      applyTransform();
    }, {passive:false});

    // Drag to pan
    let dragging=false, px=0, py=0;
    stage.addEventListener('pointerdown', e=>{
      if(e.button!==0) return;
      dragging=true; px=e.clientX; py=e.clientY;
      stage.setPointerCapture(e.pointerId);
      stage.classList.add('dragging');
    });
    stage.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx = e.clientX - px;
      const dy = e.clientY - py;
      px = e.clientX; py = e.clientY;
      tx += dx; ty += dy;
      applyTransform();
    });
    stage.addEventListener('pointerup', e=>{
      dragging=false;
      stage.releasePointerCapture(e.pointerId);
      stage.classList.remove('dragging');
    });

    // Buttons
    document.getElementById('btnZoomIn').onclick = ()=> zoomAtCenter(1.15);
    document.getElementById('btnZoomOut').onclick = ()=> zoomAtCenter(1/1.15);
    document.getElementById('btnReset').onclick = ()=> { scale=1; centerOn(0,0); applyTransform(); };
    document.getElementById('btnFit').onclick = ()=> fitToContent();
    window.addEventListener('resize', ()=> fitToContent());

    // Fit view initially
    fitToContent();

    /* -----------------------------
       Tooltip population
       ----------------------------- */
    function showTip(title, tags){
      const defs = (tags||[])
        .map(t => GLOSSARY[t])
        .filter(Boolean)
        .map(text => `<div class="def"><code>${escapeHTML(getAcr(text))}</code> ${escapeHTML(text)}</div>`)
        .join("");
      tip.innerHTML = `<h3>${escapeHTML(title)}</h3>` +
                      (defs || `<p class="mini">Hover other cards to see plain definitions.</p>`);
    }
    function getAcr(text){
      // Pull acronym inside parentheses at the end
      const m = text.match(/\(([^)]+)\)\.?$/);
      return m ? m[1] : "INFO";
    }

    /* -----------------------------
       Render helpers
       ----------------------------- */
    function addCard(n){
      const el = document.createElement('div');
      el.className = `card ${n.cls||""}`;
      el.style.left = n.x + "px";
      el.style.top  = n.y + "px";
      el.style.width = n.w + "px";
      el.style.height = n.h + "px";

      const chips = (n.tags||[]).map(t=>`<span class="tag">${escapeHTML(t)}</span>`).join("");
      el.innerHTML = `
        <div class="chips">${chips}</div>
        <div class="name">${escapeHTML(n.name)}</div>
        <div class="what"><b>What it does</b>: ${escapeHTML(n.what)}</div>
        <div class="link"><b>How it links</b>: ${escapeHTML(n.link)}</div>
      `;
      el.addEventListener('mouseenter', ()=> showTip(n.name, n.tags));
      el.addEventListener('focus', ()=> showTip(n.name, n.tags));
      nodes.appendChild(el);
    }

    function drawGrid(x,y,w,h,step){
      grid.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
      for(let gx=x; gx<=x+w; gx+=step){
        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("x1", gx); ln.setAttribute("y1", y);
        ln.setAttribute("x2", gx); ln.setAttribute("y2", y+h);
        grid.appendChild(ln);
      }
      for(let gy=y; gy<=y+h; gy+=step){
        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("x1", x); ln.setAttribute("y1", gy);
        ln.setAttribute("x2", x+w); ln.setAttribute("y2", gy);
        grid.appendChild(ln);
      }
    }

    function drawEdge(ax,ay,bx,by,isCenter){
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      // Smooth cubic curve midpoint
      const mx = (ax+bx)/2;
      const d = `M ${ax} ${ay} C ${mx} ${ay}, ${mx} ${by}, ${bx} ${by}`;
      path.setAttribute("d", d);
      path.setAttribute("class", isCenter ? "edge center" : "edge");
      edges.appendChild(path);
    }

    function applyTransform(){
      viewport.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      zoomVal.textContent = Math.round(scale*100) + "%";
    }

    function fitToContent(){
      const boxes = [];
      boxes.push(centerNode);
      hubs.forEach(h=> boxes.push(h));
      leaves.forEach(l=> boxes.push(l));

      const b = boxes.reduce((o,r)=>({
        minX: Math.min(o.minX, r.x), minY: Math.min(o.minY, r.y),
        maxX: Math.max(o.maxX, r.x + r.w), maxY: Math.max(o.maxY, r.y + r.h)
      }), {minX:Infinity, minY:Infinity, maxX:-Infinity, maxY:-Infinity});

      const margin = 800;
      const w = (b.maxX - b.minX) + margin*2;
      const h = (b.maxY - b.minY) + margin*2;

      const vw = stage.clientWidth;
      const vh = stage.clientHeight;

      scale = clamp(Math.min(vw / w, vh / h), 0.2, maxScale);
      const cx = (b.minX + b.maxX)/2;
      const cy = (b.minY + b.maxY)/2;

      // place content center at stage center
      tx = vw/2 - cx*scale;
      ty = vh/2 - cy*scale;

      applyTransform();
    }

    function zoomAtCenter(mult){
      const vw = stage.clientWidth, vh = stage.clientHeight;
      const prev = scale;
      scale = clamp(prev*mult, minScale, maxScale);
      const px = (vw/2 - tx)/prev, py = (vh/2 - ty)/prev;
      tx = vw/2 - px*scale; ty = vh/2 - py*scale;
      applyTransform();
    }

    /* Math helpers */
    function polar(cx,cy,r,deg){ const t=deg*Math.PI/180; return {x:cx+r*Math.cos(t), y:cy+r*Math.sin(t)}; }
    function norm(v){ const n=Math.hypot(v.x,v.y)||1; return {x:v.x/n, y:v.y/n}; }
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function escapeHTML(s){ return (s||"").replace(/[&<>"]/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }
  </script>
</body>
</html>
